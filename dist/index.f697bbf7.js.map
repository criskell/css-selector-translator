{"mappings":"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","sources":["node_modules/css-what/lib/es/types.js","node_modules/css-what/lib/es/parse.js","node_modules/css-what/lib/es/stringify.js","lib/humanize.js","lib/compoundSelector.js","lib/token.js","lib/complexSelector.js","lib/translator.js","lib/index.js","ui/ui.js"],"sourcesContent":["export var SelectorType;\n(function (SelectorType) {\n    SelectorType[\"Attribute\"] = \"attribute\";\n    SelectorType[\"Pseudo\"] = \"pseudo\";\n    SelectorType[\"PseudoElement\"] = \"pseudo-element\";\n    SelectorType[\"Tag\"] = \"tag\";\n    SelectorType[\"Universal\"] = \"universal\";\n    // Traversals\n    SelectorType[\"Adjacent\"] = \"adjacent\";\n    SelectorType[\"Child\"] = \"child\";\n    SelectorType[\"Descendant\"] = \"descendant\";\n    SelectorType[\"Parent\"] = \"parent\";\n    SelectorType[\"Sibling\"] = \"sibling\";\n    SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\n})(SelectorType || (SelectorType = {}));\n/**\n * Modes for ignore case.\n *\n * This could be updated to an enum, and the object is\n * the current stand-in that will allow code to be updated\n * without big changes.\n */\nexport const IgnoreCaseMode = {\n    Unknown: null,\n    QuirksMode: \"quirks\",\n    IgnoreCase: true,\n    CaseSensitive: false,\n};\nexport var AttributeAction;\n(function (AttributeAction) {\n    AttributeAction[\"Any\"] = \"any\";\n    AttributeAction[\"Element\"] = \"element\";\n    AttributeAction[\"End\"] = \"end\";\n    AttributeAction[\"Equals\"] = \"equals\";\n    AttributeAction[\"Exists\"] = \"exists\";\n    AttributeAction[\"Hyphen\"] = \"hyphen\";\n    AttributeAction[\"Not\"] = \"not\";\n    AttributeAction[\"Start\"] = \"start\";\n})(AttributeAction || (AttributeAction = {}));\n","import { SelectorType, AttributeAction, } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([\n    [126 /* Tilde */, AttributeAction.Element],\n    [94 /* Circumflex */, AttributeAction.Start],\n    [36 /* Dollar */, AttributeAction.End],\n    [42 /* Asterisk */, AttributeAction.Any],\n    [33 /* ExclamationMark */, AttributeAction.Not],\n    [124 /* Pipe */, AttributeAction.Hyphen],\n]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"where\",\n    \"host\",\n    \"host-context\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nexport function isTraversal(selector) {\n    switch (selector.type) {\n        case SelectorType.Adjacent:\n        case SelectorType.Child:\n        case SelectorType.Descendant:\n        case SelectorType.Parent:\n        case SelectorType.Sibling:\n        case SelectorType.ColumnCombinator:\n            return true;\n        default:\n            return false;\n    }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    const high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 9 /* Tab */ ||\n        c === 10 /* NewLine */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nexport function parse(selector) {\n    const subselects = [];\n    const endIndex = parseSelector(subselects, `${selector}`, 0);\n    if (endIndex < selector.length) {\n        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n    }\n    return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n    let tokens = [];\n    function getName(offset) {\n        const match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n        }\n        const [name] = match;\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        selectorIndex += offset;\n        while (selectorIndex < selector.length &&\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\n            selectorIndex++;\n        }\n    }\n    function readValueWithParenthesis() {\n        selectorIndex += 1;\n        const start = selectorIndex;\n        let counter = 1;\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n            if (selector.charCodeAt(selectorIndex) ===\n                40 /* LeftParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter++;\n            }\n            else if (selector.charCodeAt(selectorIndex) ===\n                41 /* RightParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter--;\n            }\n        }\n        if (counter) {\n            throw new Error(\"Parenthesis not matched\");\n        }\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\n    }\n    function isEscaped(pos) {\n        let slashCount = 0;\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    function addTraversal(type) {\n        if (tokens.length > 0 &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens[tokens.length - 1].type = type;\n            return;\n        }\n        ensureNotTraversal();\n        tokens.push({ type });\n    }\n    function addSpecialAttribute(name, action) {\n        tokens.push({\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value: getName(1),\n            namespace: null,\n            ignoreCase: \"quirks\",\n        });\n    }\n    /**\n     * We have finished parsing the current part of the selector.\n     *\n     * Remove descendant tokens at the end if they exist,\n     * and return the last index, so that parsing can be\n     * picked up from here.\n     */\n    function finalizeSubselector() {\n        if (tokens.length &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens.pop();\n        }\n        if (tokens.length === 0) {\n            throw new Error(\"Empty sub-selector\");\n        }\n        subselects.push(tokens);\n    }\n    stripWhitespace(0);\n    if (selector.length === selectorIndex) {\n        return selectorIndex;\n    }\n    loop: while (selectorIndex < selector.length) {\n        const firstChar = selector.charCodeAt(selectorIndex);\n        switch (firstChar) {\n            // Whitespace\n            case 32 /* Space */:\n            case 9 /* Tab */:\n            case 10 /* NewLine */:\n            case 12 /* FormFeed */:\n            case 13 /* CarriageReturn */: {\n                if (tokens.length === 0 ||\n                    tokens[0].type !== SelectorType.Descendant) {\n                    ensureNotTraversal();\n                    tokens.push({ type: SelectorType.Descendant });\n                }\n                stripWhitespace(1);\n                break;\n            }\n            // Traversals\n            case 62 /* GreaterThan */: {\n                addTraversal(SelectorType.Child);\n                stripWhitespace(1);\n                break;\n            }\n            case 60 /* LessThan */: {\n                addTraversal(SelectorType.Parent);\n                stripWhitespace(1);\n                break;\n            }\n            case 126 /* Tilde */: {\n                addTraversal(SelectorType.Sibling);\n                stripWhitespace(1);\n                break;\n            }\n            case 43 /* Plus */: {\n                addTraversal(SelectorType.Adjacent);\n                stripWhitespace(1);\n                break;\n            }\n            // Special attribute selectors: .class, #id\n            case 46 /* Period */: {\n                addSpecialAttribute(\"class\", AttributeAction.Element);\n                break;\n            }\n            case 35 /* Hash */: {\n                addSpecialAttribute(\"id\", AttributeAction.Equals);\n                break;\n            }\n            case 91 /* LeftSquareBracket */: {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                let name;\n                let namespace = null;\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n                    // Equivalent to no namespace\n                    name = getName(1);\n                }\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    name = getName(2);\n                }\n                else {\n                    name = getName(0);\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                        selector.charCodeAt(selectorIndex + 1) !==\n                            61 /* Equal */) {\n                        namespace = name;\n                        name = getName(1);\n                    }\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                let action = AttributeAction.Exists;\n                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charCodeAt(selectorIndex + 1) !==\n                        61 /* Equal */) {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n                    action = AttributeAction.Equals;\n                    stripWhitespace(1);\n                }\n                // Determine value\n                let value = \"\";\n                let ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\n                        const quote = selector.charCodeAt(selectorIndex);\n                        let sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charCodeAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        const valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\n                                selector.charCodeAt(selectorIndex) !==\n                                    93 /* RightSquareBracket */) ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === 115 /* LowerS */) {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === 105 /* LowerI */) {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                if (selector.charCodeAt(selectorIndex) !==\n                    93 /* RightSquareBracket */) {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                const attributeSelector = {\n                    type: SelectorType.Attribute,\n                    name,\n                    action,\n                    value,\n                    namespace,\n                    ignoreCase,\n                };\n                tokens.push(attributeSelector);\n                break;\n            }\n            case 58 /* Colon */: {\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n                    tokens.push({\n                        type: SelectorType.PseudoElement,\n                        name: getName(2).toLowerCase(),\n                        data: selector.charCodeAt(selectorIndex) ===\n                            40 /* LeftParenthesis */\n                            ? readValueWithParenthesis()\n                            : null,\n                    });\n                    continue;\n                }\n                const name = getName(1).toLowerCase();\n                let data = null;\n                if (selector.charCodeAt(selectorIndex) ===\n                    40 /* LeftParenthesis */) {\n                    if (unpackPseudos.has(name)) {\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n                        if (selector.charCodeAt(selectorIndex) !==\n                            41 /* RightParenthesis */) {\n                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        data = readValueWithParenthesis();\n                        if (stripQuotesFromPseudos.has(name)) {\n                            const quot = data.charCodeAt(0);\n                            if (quot === data.charCodeAt(data.length - 1) &&\n                                isQuote(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                        }\n                        data = unescapeCSS(data);\n                    }\n                }\n                tokens.push({ type: SelectorType.Pseudo, name, data });\n                break;\n            }\n            case 44 /* Comma */: {\n                finalizeSubselector();\n                tokens = [];\n                stripWhitespace(1);\n                break;\n            }\n            default: {\n                if (selector.startsWith(\"/*\", selectorIndex)) {\n                    const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n                    if (endIndex < 0) {\n                        throw new Error(\"Comment was not terminated\");\n                    }\n                    selectorIndex = endIndex + 2;\n                    // Remove leading whitespace\n                    if (tokens.length === 0) {\n                        stripWhitespace(0);\n                    }\n                    break;\n                }\n                let namespace = null;\n                let name;\n                if (firstChar === 42 /* Asterisk */) {\n                    selectorIndex += 1;\n                    name = \"*\";\n                }\n                else if (firstChar === 124 /* Pipe */) {\n                    name = \"\";\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n                        addTraversal(SelectorType.ColumnCombinator);\n                        stripWhitespace(2);\n                        break;\n                    }\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    name = getName(0);\n                }\n                else {\n                    break loop;\n                }\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n                    namespace = name;\n                    if (selector.charCodeAt(selectorIndex + 1) ===\n                        42 /* Asterisk */) {\n                        name = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name = getName(1);\n                    }\n                }\n                tokens.push(name === \"*\"\n                    ? { type: SelectorType.Universal, namespace }\n                    : { type: SelectorType.Tag, name, namespace });\n            }\n        }\n    }\n    finalizeSubselector();\n    return selectorIndex;\n}\n","import { SelectorType, AttributeAction } from \"./types\";\nconst attribValChars = [\"\\\\\", '\"'];\nconst pseudoValChars = [...attribValChars, \"(\", \")\"];\nconst charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInName = new Set([\n    ...pseudoValChars,\n    \"~\",\n    \"^\",\n    \"$\",\n    \"*\",\n    \"+\",\n    \"!\",\n    \"|\",\n    \":\",\n    \"[\",\n    \"]\",\n    \" \",\n    \".\",\n].map((c) => c.charCodeAt(0)));\n/**\n * Turns `selector` back into a string.\n *\n * @param selector Selector to stringify.\n */\nexport function stringify(selector) {\n    return selector\n        .map((token) => token.map(stringifyToken).join(\"\"))\n        .join(\", \");\n}\nfunction stringifyToken(token, index, arr) {\n    switch (token.type) {\n        // Simple types\n        case SelectorType.Child:\n            return index === 0 ? \"> \" : \" > \";\n        case SelectorType.Parent:\n            return index === 0 ? \"< \" : \" < \";\n        case SelectorType.Sibling:\n            return index === 0 ? \"~ \" : \" ~ \";\n        case SelectorType.Adjacent:\n            return index === 0 ? \"+ \" : \" + \";\n        case SelectorType.Descendant:\n            return \" \";\n        case SelectorType.ColumnCombinator:\n            return index === 0 ? \"|| \" : \" || \";\n        case SelectorType.Universal:\n            // Return an empty string if the selector isn't needed.\n            return token.namespace === \"*\" &&\n                index + 1 < arr.length &&\n                \"name\" in arr[index + 1]\n                ? \"\"\n                : `${getNamespace(token.namespace)}*`;\n        case SelectorType.Tag:\n            return getNamespacedName(token);\n        case SelectorType.PseudoElement:\n            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;\n        case SelectorType.Pseudo:\n            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${typeof token.data === \"string\"\n                    ? escapeName(token.data, charsToEscapeInPseudoValue)\n                    : stringify(token.data)})`}`;\n        case SelectorType.Attribute: {\n            if (token.name === \"id\" &&\n                token.action === AttributeAction.Equals &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `#${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            if (token.name === \"class\" &&\n                token.action === AttributeAction.Element &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `.${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            const name = getNamespacedName(token);\n            if (token.action === AttributeAction.Exists) {\n                return `[${name}]`;\n            }\n            return `[${name}${getActionValue(token.action)}=\"${escapeName(token.value, charsToEscapeInAttributeValue)}\"${token.ignoreCase === null ? \"\" : token.ignoreCase ? \" i\" : \" s\"}]`;\n        }\n    }\n}\nfunction getActionValue(action) {\n    switch (action) {\n        case AttributeAction.Equals:\n            return \"\";\n        case AttributeAction.Element:\n            return \"~\";\n        case AttributeAction.Start:\n            return \"^\";\n        case AttributeAction.End:\n            return \"$\";\n        case AttributeAction.Any:\n            return \"*\";\n        case AttributeAction.Not:\n            return \"!\";\n        case AttributeAction.Hyphen:\n            return \"|\";\n        case AttributeAction.Exists:\n            throw new Error(\"Shouldn't be here\");\n    }\n}\nfunction getNamespacedName(token) {\n    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;\n}\nfunction getNamespace(namespace) {\n    return namespace !== null\n        ? `${namespace === \"*\"\n            ? \"*\"\n            : escapeName(namespace, charsToEscapeInName)}|`\n        : \"\";\n}\nfunction escapeName(str, charsToEscape) {\n    let lastIdx = 0;\n    let ret = \"\";\n    for (let i = 0; i < str.length; i++) {\n        if (charsToEscape.has(str.charCodeAt(i))) {\n            ret += `${str.slice(lastIdx, i)}\\\\${str.charAt(i)}`;\n            lastIdx = i + 1;\n        }\n    }\n    return ret.length > 0 ? ret + str.slice(lastIdx) : str;\n}\n","const quoteCode = (code) => \"`\" + code + \"`\";\n\nconst capitalize = (string) => string[0].toUpperCase() + string.slice(1);\n\nconst translateArray = (array, lastSep = \" e \") => {\n  if (array.length === 0) return \"\";\n  if (array.length === 1) return array[0];\n\n  const init = array.splice(0, array.length - 1);\n  const tail = array[array.length - 1];\n\n  return init.join(\", \") + lastSep + tail;\n};\n\nmodule.exports = {\n  quoteCode,\n  capitalize,\n  translateArray,\n};","const { quoteCode, translateArray } = require(\"./humanize\");\nconst { groupTokens } = require(\"./token\");\n\nconst translateAttributeAction = (action, value) => {\n  const quoted = quoteCode(value);\n\n  return (\n    {\n      equals: `**exatamente igual** ao valor ${quoted}`,\n      hyphen: `**começando com, ou sendo igual ao**, valor ${quoted + \"-\"}`,\n      any: `tendo ${quoted} em **qualquer posição**`,\n      start: `**começando** com ${quoted}`,\n      end: `**terminando** com o valor ${quoted}`,\n    }[action] ?? \"\"\n  );\n};\n\nconst translateAttribute = (attribute) => {\n  const action = translateAttributeAction(attribute.action, attribute.value);\n\n  return (\n    `um atributo ${quoteCode(attribute.name)}` +\n    (action ? ` com o valor ${action}` : \"\")\n  );\n};\n\nconst translateCompoundSelector = (tokens) => {\n  const tokenGrouping = groupTokens(tokens);\n  const { classes, identifier, attributes } = tokenGrouping;\n\n  const identifierTranslation = identifier\n    ? `o identificador ${quoteCode(identifier.value)}`\n    : \"\";\n  const classTranslation = classes.length\n    ? (classes.length > 1 ? \"as classes \" : \"a classe \") +\n      translateArray(classes.map(({ value }) => quoteCode(value)))\n    : \"\";\n  const attributeTranslation = translateArray(\n    attributes.map(translateAttribute)\n  );\n\n  return [\n    \"um elemento\",\n    tokenGrouping.element\n      ? `do tipo ${quoteCode(tokenGrouping.element.name)}`\n      : \"de qualquer tipo\",\n    identifierTranslation || classTranslation || attributeTranslation\n      ? \"que tem \" +\n        translateArray(\n          [\n            identifierTranslation,\n            classTranslation,\n            attributeTranslation,\n          ].filter((x) => x)\n        )\n      : \"\",\n  ]\n    .filter((x) => x)\n    .join(\" \");\n};\n\nmodule.exports = {\n  translateAttributeAction,\n  translateAttribute,\n  translateCompoundSelector,\n};","const isCombinator = (token) =>\n  [\"child\", \"sibling\", \"adjacent\", \"descendant\"].includes(token.type);\n\nconst isAttribute = (token) => token.type === \"attribute\";\n\nconst isClass = (token) =>\n  isAttribute(token) && token.name === \"class\" && token.action === \"element\";\n\nconst isIdentifier = (token) =>\n  isAttribute(token) && token.name === \"id\" && token.action === \"equals\";\n\nconst isElement = (token) => token.type === \"tag\";\n\nconst isPseudoElement = (token) => token.type === \"pseudo-element\";\n\nconst getTokenGroup = (token) => {\n  if (isClass(token)) return \"classes\";\n  if (isIdentifier(token)) return \"identifier\";\n  if (isAttribute(token)) return \"attributes\";\n  if (isPseudoElement(token)) return \"pseudoElement\";\n  if (isElement(token)) return \"element\";\n  return token.type;\n};\n\nconst groupTokens = (tokens) =>\n  tokens.reduce(\n    (grouping, token) => {\n      const group = getTokenGroup(token);\n\n      return {\n        ...grouping,\n        [group]:\n          grouping[group] instanceof Array\n            ? [...grouping[group], token]\n            : token,\n      };\n    },\n    {\n      element: null,\n      pseudoElement: null,\n      identifier: null,\n      attributes: [],\n      classes: [],\n    }\n  );\n\nmodule.exports = {\n  isCombinator,\n  isAttribute,\n  isClass,\n  isIdentifier,\n  isElement,\n  isPseudoElement,\n  getTokenGroup,\n  groupTokens,\n};","const { translateCompoundSelector } = require(\"./compoundSelector\");\nconst { capitalize } = require(\"./humanize\");\nconst { isCombinator } = require(\"./token\");\n\nconst splitByCombinator = (tokens) =>\n  tokens.reduce(\n    ([first, ...rest], token) =>\n      isCombinator(token)\n        ? [[], token, first, ...rest]\n        : [[token, ...first], ...rest],\n    [[]]\n  );\n\nconst translateComplexSelector = (tokens) => {\n  const split = splitByCombinator(tokens);\n\n  const compoundSelectors = split.map((combinatorOrTokenList, index) => {\n    if (combinatorOrTokenList instanceof Array) {\n      const selectorTranslation = translateCompoundSelector(\n        combinatorOrTokenList\n      );\n\n      return capitalize(selectorTranslation);\n    }\n\n    const combinatorTranslation = {\n      descendant: \"É **descendente**\",\n      sibling: \"Está **logo após**\",\n      adjacent: \"Está **imediatamente ao lado**\",\n      child: \"É **filho direto**\",\n    }[combinatorOrTokenList.type];\n\n    return `. ${combinatorTranslation} de...\\n`;\n    })\n    .join(\"\") + \".\";\n\n  return compoundSelectors;\n};\n\nmodule.exports = {\n  splitByCombinator,\n  translateComplexSelector,\n};","const CSSwhat = require(\"css-what\");\nconst { translateComplexSelector } = require(\"./complexSelector\");\n\nconst translate = (selector) => {\n  if (!selector) return [];\n\n  const selectorList = CSSwhat.parse(selector);\n\n  return selectorList.map((tokens) => ({\n    from: CSSwhat.stringify([tokens]),\n    to: translateComplexSelector(tokens),\n  }));\n};\n\nmodule.exports = { translate };","const { translate } = require(\"./translator\");\n\nmodule.exports = { translate };","import { translate } from \"../lib\";\n\nconst $output = document.querySelector(\"#terminal-output\");\n\ndocument.querySelector(\"#terminal-input\").addEventListener(\"input\", (e) => {\n  const selector = e.target.value;\n\n  const translations = translate(selector);\n  const compiled = translations.length > 0 ? \"<div>\" + translations.map(\n    (translation) => {\n      const output = \"Começando do lado direito, temos: \" + translation.to;\n\n      return `<p class=\"selector-intro\">Analisando o seletor <code>${translation.from}</code>...</p>`\n      + compileSimpleMarkdown(escape(output))\n      + \"</div>\";\n    }\n  ).join(\"<div>\") : \"\";\n\n  $output.innerHTML = compiled;\n});\n\nfunction compileSimpleMarkdown(markdown) {\n  return markdown.replace(/\\`(.*?)\\`/g, \"<code>$1</code>\")\n    .replace(/\\*\\*(.*?)\\*\\*/g, \"<strong>$1</strong>\")\n    .replace(/(.+?)(\\n|$)+/g, \"<p>$1</p>\");\n}\n\nfunction escape(html) {\n  return html\n   .replace(/&/g, \"&amp;\")\n   .replace(/</g, \"&lt;\")\n   .replace(/>/g, \"&gt;\")\n   .replace(/\"/g, \"&quot;\")\n   .replace(/'/g, \"&#039;\");\n}"],"names":["$6de3987936ef985e$export$4e8b093ec8dcab0d","SelectorType","$6de3987936ef985e$export$dbc3de62b8fcdc89","AttributeAction","$093d7ffb078d3faf$var$reName","$093d7ffb078d3faf$var$reEscape","$093d7ffb078d3faf$var$actionTypes","Map","Element","Start","End","Any","Not","Hyphen","$093d7ffb078d3faf$var$unpackPseudos","Set","$093d7ffb078d3faf$var$stripQuotesFromPseudos","$093d7ffb078d3faf$var$funescape","_","escaped","escapedWhitespace","high","parseInt","String","fromCharCode","$093d7ffb078d3faf$var$unescapeCSS","str","replace","$093d7ffb078d3faf$var$isQuote","c","$093d7ffb078d3faf$var$isWhitespace","$093d7ffb078d3faf$export$98e6a39c04603d36","selector","subselects","endIndex","$093d7ffb078d3faf$var$parseSelector","length","Error","slice","selectorIndex","tokens","getName","offset","match","name","stripWhitespace","charCodeAt","readValueWithParenthesis","start","counter","isEscaped","pos","slashCount","ensureNotTraversal","type","Adjacent","Child","Descendant","Parent","Sibling","ColumnCombinator","$093d7ffb078d3faf$export$41d1fe2780697dca","addTraversal","push","addSpecialAttribute","action","Attribute","value","namespace","ignoreCase","finalizeSubselector","pop","loop","firstChar","Equals","startsWith","Exists","possibleAction","get","quote","sectionEnd","valueStart","forceIgnore","attributeSelector","PseudoElement","toLowerCase","data","name1","has","quot","Pseudo","indexOf","name2","namespace1","test","Universal","Tag","$936fdcddb4ddadc3$var$attribValChars","$936fdcddb4ddadc3$var$pseudoValChars","$936fdcddb4ddadc3$var$charsToEscapeInAttributeValue","map","$936fdcddb4ddadc3$var$charsToEscapeInPseudoValue","$936fdcddb4ddadc3$var$charsToEscapeInName","$936fdcddb4ddadc3$export$fac44ee5b035f737","token","$936fdcddb4ddadc3$var$stringifyToken","join","index","arr","$936fdcddb4ddadc3$var$getNamespace","$936fdcddb4ddadc3$var$getNamespacedName","$936fdcddb4ddadc3$var$escapeName","$936fdcddb4ddadc3$var$getActionValue","charsToEscape","lastIdx","ret","i","charAt","$090776fe6b9d783d$exports","code","string","toUpperCase","array","lastSep","init","splice","tail","quoteCode","translateArray","$3b34c0390f758e22$var$isAttribute","$3b34c0390f758e22$var$isClass","$3b34c0390f758e22$var$isIdentifier","$3b34c0390f758e22$var$isElement","$3b34c0390f758e22$var$isPseudoElement","$3b34c0390f758e22$var$getTokenGroup","$3b34c0390f758e22$exports","includes","reduce","grouping","group","Array","element","pseudoElement","identifier","attributes","classes","groupTokens","$1625ef417634bcaf$var$translateAttributeAction","quoted","$1625ef417634bcaf$require$quoteCode","equals","hyphen","any","end","$1625ef417634bcaf$var$translateAttribute","attribute","tokenGrouping","$1625ef417634bcaf$require$groupTokens","identifierTranslation","classTranslation","$1625ef417634bcaf$require$translateArray","attributeTranslation","filter","x","translateCompoundSelector","capitalize","isCombinator","$9ddd90f0e1caadf3$var$splitByCombinator","first","rest","$9ddd90f0e1caadf3$require$isCombinator","combinatorOrTokenList","selectorTranslation","$9ddd90f0e1caadf3$require$translateCompoundSelector","$9ddd90f0e1caadf3$require$capitalize","descendant","sibling","adjacent","child","translateComplexSelector","$f3ad373832d6cae4$exports","from","to","$68279bc872e471b6$require$translateComplexSelector","translate","$511fe8d0ad7bd101$var$$output","document","querySelector","addEventListener","e","target","translations","compiled","translation","output","innerHTML"],"version":3,"file":"index.f697bbf7.js.map"}